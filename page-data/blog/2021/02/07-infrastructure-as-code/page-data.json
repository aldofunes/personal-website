{"componentChunkName":"component---src-templates-blog-post-index-tsx","path":"/blog/2021/02/07-infrastructure-as-code/","result":{"data":{"markdownRemark":{"html":"<h1>Introduction</h1>\n<p>This is a summary of the book <strong>Infrastructure as Code (2nd edition)</strong> by Kief Morris, where I state the things that stood out the most to me.</p>\n<h1>What is Infrastructure as Code?</h1>\n<p>Organizations are becoming increasingly \"digital\" <sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup>, and as they do, the IT infrastructure becomes more and more complex: more services, more users, more business activities, suppliers, products, customers, stakeholders... and the list goes on and on.</p>\n<p>Infrastructure automation tools help manage this complexity by keeping the entire infrastructure as code. This will help by optimizing for change. People say: we don’t make changes often enough to justify automating them; we should build first, automate later; we must choose between speed and quality. These all lead to a \"Fragile Mess\"; changing the infrastructure becomes a cumbersome error-prone process.</p>\n<p>When prioritizing quality, many organizations put in place complex processes to change even the tiniest detail of their infrastructure; which eventually are forgotten due to an approaching deadline. Other companies prioritize speed (move fast and break things); infrastructure that \"just works, but no one knows how\" is a very dangerous thing to have. Making changes to it becomes more an obscure art than a clear process. The only sustainable way of maintaining infrastructure is by prioritizing equally both quality and speed; this may seem like an unattainable ideal, but it is where we find high performers.</p>\n<p><a href=\"https://www.devops-research.com/research.html\">Dora</a> identified four key metrics in their <em>Accelerate</em> research:</p>\n<ol>\n<li><strong>Delivery lead time</strong>: The elapsed time it takes to implement, test, and deliver changes to the production system</li>\n<li><strong>Deployment frequency</strong>: How often you deploy changes to production systems</li>\n<li><strong>Change fail percentage</strong>: What percentage of changes either cause an impaired service or need immediate correction, such as a rollback or emergency fix</li>\n<li><strong>Mean Time to Restore (MTTR)</strong>: How long it takes to restore service when there is an unplanned outage or impairment Organizations that perform well against</li>\n</ol>\n<h1>Core Practices</h1>\n<ul>\n<li><strong>Define everything as code</strong>: Enables reusability, consistency and transparency</li>\n<li><strong>Continuously test and deliver all work in progress</strong>: Build quality in instead of trying to test quality in</li>\n<li><strong>Build small, simple pieces that you can change independently</strong>: The larger a system is, the harder it is to change, and the easier it is to break.</li>\n</ul>\n<h1>Principles</h1>\n<ul>\n<li><strong>Assume systems are unreliable</strong>: Cloud scale infrastructure has so many moving parts, that even when using reliable hardware, systems fail</li>\n<li><strong>Make everything reproducible</strong>: It removes the fear and risk of making changes</li>\n<li><strong>Create disposable things</strong>: It should be possible to add, remove, start, stop, change and move parts of the the system. The cloud abstracts resources (storage, compute, networking) from physical hardware. The system should be able to dispose faulty parts and heal itself.</li>\n<li><strong>Minimize variation</strong>: Keep the minimum number of different <em>types</em> of pieces possible; It’s easier to manage one hundred identical servers than five completely different servers.</li>\n<li><strong>Ensure you can repeat any process</strong>: This will help make things reproducible</li>\n</ul>\n<p>Of course, to use code to define and manage infrastructure, a dynamic infrastructure platform is required. The platform should expose its functionality to provision resources via APIs or something of the sorts, think Amazon Web Services, Microsoft Azure, Google Cloud Platform, Digital Ocean, even VMWare.</p>\n<h1>Infrastructure code</h1>\n<p>If I want to create a server, it is easier, and faster to go to the platform (AWS) and click through the GUI instead of writing a script for it. On the other hand, provisioning it through code will make the process reusable, consistent and transparent. It is obvious that defining this server as code, is the better approach. Defining everything as code enables you to leverage speed to improve quality, much like Agile uses speed to improve software quality by having tight feedback loops and iterating on that feedback.</p>\n<p>Infrastructure code can use declarative or imperative languages<sup id=\"fnref-2\"><a href=\"#fn-2\" class=\"footnote-ref\">2</a></sup>.</p>\n<h1>Infrastructure stacks</h1>\n<p>An infrastructure stack is a group of resources that are defined, provisioned and updated as a unit. For example: A stack may include a virtual machine, a disk volume and a subnet.</p>\n<p>Examples of stack management tools include:</p>\n<ul>\n<li><a href=\"https://www.terraform.io/\">HashiCorp Terraform</a></li>\n<li><a href=\"https://aws.amazon.com/cloudformation/\">AWS CloudFormation</a></li>\n<li><a href=\"https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/overview\">Azure Resource Manager</a></li>\n<li><a href=\"https://cloud.google.com/deployment-manager/docs/\">Google Cloud Deployment Manager</a></li>\n<li><a href=\"https://wiki.openstack.org/wiki/Heat\">OpenStack Heat</a></li>\n<li><a href=\"https://www.pulumi.com/\">Pulumi</a></li>\n<li><a href=\"https://bosh.io/docs/\">Bosh</a></li>\n</ul>\n<h2>Patterns and Antipatterns for Structuring Stacks</h2>\n<p>One challenge with infrastructure design is deciding how to size and structure stacks.</p>\n<h3>Antipatterns</h3>\n<ul>\n<li><strong>Monolithic stack</strong>: An entire system into one stack. Changing a large stack is riskier than changing a smaller stack. More things can go wrong. Larger stacks take longer to provision and change. Because of the risk and slowness, people make less changes to it, and with less frequency. This increases the levels of technical debt</li>\n</ul>\n<h3>Patterns</h3>\n<ul>\n<li><strong>Application group stack</strong>: Multiple, related pieces of a system into stacks. It's common for application group stacks to grow into monolithic stacks; but it can work well when a single team owns the infrastructure of all the pieces of an application.</li>\n<li><strong>Service stack</strong>: Infrastructure for a single application into a single stack. Service stacks align the boundaries of infrastructure to the software that runs on it. There could be an unnecessary duplication of code, which can encourage inconsistency. Reusing shareable modules is encouraged.</li>\n<li><strong>Micro stack</strong>: Breaks the infrastructure for a given application or service into multiple stacks. Different parts of a service’s infrastructure may change at different rates. Although parts are smaller, having many of them increases complexity.</li>\n</ul>\n<h1>Building Environments with Stacks</h1>\n<p>Environments and stacks are both collections of resources. What makes environments different is that they are organized around a particular purpose (support the testing phase, provide service in a geographical region). An environment is composed by one or multiple stacks. Although possible, a stack should not provision multiple environments.</p>\n<p>Consistency across environments is one of the main drivers of Infrastructure as Code. If the testing environment is not the same as the one in production, you may find that some things behave differently; you may even push broken code that \"works\" in the testing environment. How many time have we heard \"it runs okay in my local environment\"?</p>\n<h2>Antipattern: Multi-Environment Stack</h2>\n<p>It defines and manages multiple environments in a single stack instance. Every time you change a testing environment, you risk breaking the production if there was a mistake, a bug in the tools or somewhere in the pipeline.</p>\n<h2>Antipattern: Copy-Paste Environment</h2>\n<p>It uses separate source-code projects to manage each environment. Because environments should be identical, people resort to copy-pasting the code from the modified stack into the other ones. As you can imagine, this can get messy pretty fast. Maybe some tweaks to reduce costs are incompatible with the production environment. This causes configuration drift, and makes it confusing for people looking at the code for the first time.</p>\n<h2>Pattern: Reusable Stack</h2>\n<p>Here, you maintain a single source-code project, with enough configuration parameters to provision all the required environments. However, it could be too rigid for situations where environments must be heavily customized.</p>\n<p>The reusable stack should be the foundation for any new environment. There are several ways to configure the configuration parameters it requires to be unique, let's look at those.</p>\n<h2>Antipattern: Manual Stack Parameters</h2>\n<p>The most natural approach to provide values for a stack instance is to type the values on the command line manually.</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"command-line-prompt\"><span data-user=aldo data-host=localhost></span><span></span><span data-user=aldo data-host=localhost></span><span></span><span data-user=aldo data-host=localhost></span><span></span><span data-user=aldo data-host=localhost></span><span></span></span>stack up <span class=\"token assign-left variable\">environment</span><span class=\"token operator\">=</span>production --source my-stck/src\nFAILURE: No such directory <span class=\"token string\">'my-stck/src'</span>\nstack up <span class=\"token assign-left variable\">environment</span><span class=\"token operator\">=</span>production --source my-stack/src\nSUCCESS: new stack <span class=\"token string\">'production'</span> created\nstack destroy <span class=\"token assign-left variable\">environment</span><span class=\"token operator\">=</span>production --source my-stack/src\nSUCCESS: stack <span class=\"token string\">'production'</span> destroyed\nstack up <span class=\"token assign-left variable\">environment</span><span class=\"token operator\">=</span>production --source my-stack/src\nSUCCESS: existing stack <span class=\"token string\">'production'</span> modified</code></pre></div>\n<h2>Pattern: Stack Environment Variables</h2>\n<p>The stack environment variables pattern involves setting parameter values as environment variables for the stack tool to use. This pattern is often combined with another pattern to set the environment variables.</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"command-line-prompt\"><span data-user=aldo data-host=localhost></span><span data-user=aldo data-host=localhost></span><span data-user=aldo data-host=localhost></span><span data-user=aldo data-host=localhost></span></span><span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">STACK_ENVIRONMENT</span><span class=\"token operator\">=</span>test\n<span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">STACK_CLUSTER_MINIMUM</span><span class=\"token operator\">=</span><span class=\"token number\">1</span>\n<span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">STACK_CLUSTER_MAXIMUM</span><span class=\"token operator\">=</span><span class=\"token number\">1</span>\n<span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">STACK_SSL_CERT_PASSPHRASE</span><span class=\"token operator\">=</span><span class=\"token string\">\"correct horse battery staple\"</span></code></pre></div>\n<h2>Pattern: Scripted Parameters</h2>\n<p>Scripted parameters involves hardcoding the parameter values into a script that runs the stack tool. You can write a separate script for each environment or a single script that includes the values for all of your environments</p>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token keyword\">if</span> $<span class=\"token punctuation\">{</span><span class=\"token constant\">ENV</span><span class=\"token punctuation\">}</span> <span class=\"token operator\">==</span> <span class=\"token string\">\"test\"</span>\n  stack up cluster_maximum<span class=\"token operator\">=</span><span class=\"token number\">1</span> env<span class=\"token operator\">=</span><span class=\"token string\">\"test\"</span>\n<span class=\"token keyword\">elsif</span> $<span class=\"token punctuation\">{</span><span class=\"token constant\">ENV</span><span class=\"token punctuation\">}</span> <span class=\"token operator\">==</span> <span class=\"token string\">\"staging\"</span>\n  stack up cluster_maximum<span class=\"token operator\">=</span><span class=\"token number\">3</span> env<span class=\"token operator\">=</span><span class=\"token string\">\"staging\"</span>\n<span class=\"token keyword\">elsif</span> $<span class=\"token punctuation\">{</span><span class=\"token constant\">ENV</span><span class=\"token punctuation\">}</span> <span class=\"token operator\">==</span> <span class=\"token string\">\"production\"</span>\n  stack up cluster_maximum<span class=\"token operator\">=</span><span class=\"token number\">5</span> env<span class=\"token operator\">=</span><span class=\"token string\">\"production\"</span>\n<span class=\"token keyword\">end</span></code></pre></div>\n<h2>Pattern: Stack Configuration Files</h2>\n<p>We can manage the parameters for each stack instance in separate files.</p>\n<p>For example:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">├── src/\n   │   ├── cluster.tf\n   │   ├── host_servers.tf\n   │   └── networking.tf\n   ├── environments/\n   │   ├── test.tfvars\n   │   ├── staging.tfvars\n   │   └── production.tfvars\n   └── test/</code></pre></div>\n<p>This pattern is simple and very useful when the environments don't change often, as it requires to create and commit a new configuration file per environment. It is also slower to reach the stable production environments, since these files have to progress through the various stages before being committed to the main branch.</p>\n<h2>Pattern: Wrapper Stack</h2>\n<p>Let's say we write our infrastructure code as reusable modules, kind of like a library. A wrapper stack is a code project that imports and uses those modules, passing the appropriate parameters to them. In that sense, every environment is its own code project. We can set up independent repositories for them using git. The only thing we must make sure does not get into these repos are secrets, for those we can leverage other patterns, like using environment variables, or untracked configuration files.</p>\n<p>There's a catch, though. There is added complexity by having to manage the reusable modules and the projects that use them. Furthermore, having separate projects tempt people into adding specific logic to one of them to customize it without including it upstream.</p>\n<h2>Pattern: Pipeline Stack Parameters</h2>\n<p>Delivery pipelines allow us to set at the very least environment variables via some admin panel, a CLI or even an API. We can hook up our project in one such pipeline, and let it configure our project. An added bonus is that the entire team can use it without having to share parameters or even secrets. The catch is that we become dependant on the pipeline. If for some reason, the pipeline is offline, or simply not accessible, we cannot make changes to our infrastructure.</p>\n<p>Also, the first thing attackers look for when gaining access to a network are CI/CD servers because they are full of admin-level credentials.</p>\n<h2>Pattern: Stack Parameter Registry</h2>\n<p>We can store all our parameters in a centralized registry, this can range from simple files in some file server, to a Consul cluster or a SQL database. Of course, we have to use another pattern to set the connection parameters to our registry; but once plugged it, changing it becomes a matter of executing a query, or modifying a file.</p>\n<p>The main issue with this pattern is the fact that we are adding something more to manage, the registry itself. This registry is an extra moving piece and a potential point of failure.</p>\n<h1>Testing</h1>\n<p>If good testing yields great results for application development, we can assume it will be very useful while defining our infrastructure as code.</p>\n<p>Testing infrastructure code is not easy. Many frameworks use declarative languages, which makes unit tests for these declarations somewhat useless. If we declare that we want a server with 1 CPU and 2 GB of RAM, the test that we write might check for these attributes. We are simply re-stating what we declared in the code. With this test, we are testing that the provider and the tool works as promised, not that our code does what we intend. Unit testing is reserved, then, for those sneaky pieces of code that are influenced by configuration parameters, and why not, for testing around known issues with the tools of platforms we use.</p>\n<p>The heavy burden will lie on integration tests. If we want three subnets: <code class=\"language-text\">subnet-a</code> is public, <code class=\"language-text\">subnet-b</code> is private, <code class=\"language-text\">subnet-c</code> is private and does not have access to the other subnets; we can test for exactly that, that we can reach <code class=\"language-text\">subnet-a</code> through internet, that <code class=\"language-text\">subnet-b</code> can access <code class=\"language-text\">subnet-a</code>, and that <code class=\"language-text\">subnet-c</code> cannot access the other subnets. This is much more useful, since we are testing several moving pieces. Provisioning networks include access rules, routing tables, subnet masks, internet gateways, nat gateways, and some other pieces that provisioned together will provide a useful network; we might as well test that it works like we want it to.</p>\n<p>Integration tests are slower than unit tests, since we must provision actual resources on real platforms. The slowness gets worse when we make end-to-end tests. When we provision our entire infrastructure to test, that is.</p>\n<p>The key thing is to identify risks, in our case, our risk is that we may accidentally expose <code class=\"language-text\">subnet-c</code> to the outside world; therefore we test to ensure that risk does not become a reality.</p>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">\n<p>1 \"short for 'software systems are essential for our business'</p>\n<a href=\"#fnref-1\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-2\">\n<p>2: \"Imperative code is a set of instructions that specifies how to make a thing happen. Declarative code specifies what you want, without specifying how to make it happen.\"</p>\n<a href=\"#fnref-2\" class=\"footnote-backref\">↩</a>\n</li>\n</ol>\n</div>","frontmatter":{"title":"Infrastructure as Code","date":"Feb 07, 2021"}}},"pageContext":{"slug":"/blog/2021/02/07-infrastructure-as-code/","previous":null,"next":null}},"staticQueryHashes":["2125292342","3649515864","63159454"]}